1. REPEATABLE READ допомагає вирішити наступні проблеми: 

- LOST UPDATE — типова проблема будь-якої параллельної системи, виникає коли при одночасній зміні одного блоку даних різними транзакціями, одна із змін втрачається;
- DIRTY READ — читання даних, які додані чи змінені транзакцією, яка потім відкотиться
- і, як не складно здогадатися, NON REPEATABLE READ — при повторному читанні в рамках однієї транзакції, раніше прочитані дані з’являються зміненими;

Але деякі проблеми залишаються, такі як фантомне читання: 

- PHANTOM READ(S) — проблема, що виникає коли одна транзакція в ході свого виконання декілька разів вибирає множину рядків за одними і тими ж критеріями. Інша транзакція в інтервалах між цими вибірками додає чи видаляє рядки чи змінює стовпці деяких рядків, що використовується в критеріях вибірки першої транзакції, і успішно закінчується. В результаті отримаємо, що одні і ті ж вибірки в першій транзакції дають різні множини рядків.

Для демонстації деяких потенційно проблемних ситуацій і відмінностей repeatable read від інших вівнів ізоляції наведу приклад: 

BEGIN TRANSACTION;
SELECT * FROM T;
WAITFOR DELAY '00:0:10'
SELECT * FROM T;
COMMIT;

читаємо дані, а потім читаємо їх ще раз через 1 секунду.
У випадку стандартного (дефолтного практично у всіх субд крім наскільки я пам'ятаю mysql) рівня ізоляції read committed перший і другий селект, у загальному випадку, повернуть різні дані, так як за секуну очікування дані можуть бути видалені, змінені і тд.
У випадку repeatable read другий селект поверне теж саме, що і перший + дані, що були додані, але у разі зміни чи видалення старих данних це не вплине на другий селект 
Для того, щоб отримати абсолютно однаковий результат з обох селектів можна скористатися рівнем ізоляції serializable read

2. Data mapper  надає можливість робити доволі комплексні запити, в той час як Active record
легкий у використанні, але через це втрачається інтерпритуємість. Кожен рядок,
витягнутий з бд в випадку Active Record буде обернутий в окремий об'єкт, а в
Data mapper ми можемо самі визначати його представлення. Останній більше підходить для великих проектів

3. Проблема N + 1 виникає, коли фреймворк доступу до даних виконує N додаткових SQL-запитів для отримання тих же даних, які можна отримати при виконанні одного SQL-запиту. Чим більше значення N, тим більше запитів буде виконано і тим більше вплив на продуктивність. 
приклад: 
INSERT INTO user (name, id)
VALUES ('polly', 1)

INSERT INTO user (name, id)
VALUES ('polya', 2)

INSERT INTO user (name, id)
VALUES ('paulina', 3)

INSERT INTO user (name, id)
VALUES ('polina', 4)

INSERT INTO user_post (user_id, s3_link, id)
VALUES (1, 'link 1', 1)

INSERT INTO user_post (user_id, s3_link, id)
VALUES (2, 'link 2', 2)

INSERT INTO user_post (user_id, s3_link, id)
VALUES (3, 'link 3', 3)

INSERT INTO user_post (user_id, s3_link, id)
VALUES (4, 'link 4', 4)


SELECT user.*

SELECT user_post.*
   WHERE user_post.user_id = user.id
 
4. Master відповідає за оновлення даних, а Slave відповідає за читання даних, копіюючи дані. Це корисно для бекапів, аналізу без участі MasterNode, масштабування, відмовостійкості
або як розподіл навантаження. Але, якщо MasterNode падає і
дані не синхронізуються зі SlaveNodes, дані можуть бути втрачені. Дані
SlaveNode можуть бути повільніші за MasterNode.
